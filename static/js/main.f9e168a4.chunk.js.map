{"version":3,"sources":["types/Turn.ts","types/Location.ts","types/Card.ts","types/Deck.ts","types/Player.ts","util/usePositions.ts","types/GameState.ts","util/useGameState.ts","components/Card.tsx","img/title.png","img/rules-matching.png","img/rules-discards.png","img/rules-perfect-match.png","components/Rules.tsx","components/TurnTracker.tsx","components/HandStats.tsx","components/HelpButton.tsx","components/DrawCardButton.tsx","components/OffBoarding.tsx","App.tsx","index.tsx"],"names":["Phase","Location","getLocationSortOrder","location","Center","Discard","Deck","Hand","Win","numMatches","a","b","color","wallpaper","decoration","cardToString","card","id","d","push","this","map","value","sort","Math","random","deck","colors","wallpapers","decorations","i","forEach","length","visible","pos","x","y","owner","animating","shuffle","Array","HumanStrategy","player","state","dispatch","BotStrategy","timeout","clearTimeout","cancelThoughts","paused","Wait","Pregame","Preround","includes","turn","phase","setTimeout","center","getCenter","hand","getHand","seat","bestMatch","toPlay","matches","type","Actions","Draw","payload","PlayCard","Think","toDiscard","DiscardCard","calculatePositions","size","width","height","discard","win","players","usePositions","useState","windowSize","setWindowSize","positions","setPositions","useEffect","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","initialState","cards","previousCenter","reducer","draft","action","LoadGame","StartGame","numHumans","name","strategy","numBots","create","floor","PauseGame","ResumeGame","Resize","c","Deal","baseCards","moveToCenter","find","numWins","dealCard","StartRound","filter","Play","playedCard","getCard","console","log","toast","toastId","error","moveToDiscard","WinRound","moveToWin","lastWinner","resetRound","WinGame","Postgame","FinishAnimation","Error","JSON","stringify","isHuman","getGameWinner","p","handSize","wins","shift","useGameState","useImmerReducer","gameData","localStorage","getItem","parse","key","setItem","undefined","animationRunning","roundWinner","getRoundWinner","centerChanged","onCardPlayed","onDiscardNeeded","gameWinner","Card","index","imageClass","style","top","left","zIndex","className","onClick","Rules","resume","page","setPage","instructions","src","title","alt","href","target","rel","matching","discards","perfect","disabled","TurnTracker","HandStats","isAfterFirstRound","previousPlayer","icon","HelpButton","DrawCardButton","position","OffBoarding","winner","App","useMemo","ReactDOM","render","StrictMode","autoClose","hideProgressBar","newestOnTop","closeOnClick","closeButton","rtl","pauseOnFocusLoss","draggable","pauseOnHover","toastClassName","document","getElementById"],"mappings":"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","file":"static/js/main.f9e168a4.chunk.js","sourcesContent":["export enum Phase {\n    Pregame = \"pregame\",\n    Preround = \"preround\",\n    Postgame = \"postgame\",\n    Wait = \"wait\",\n    Play = \"play\",\n    Discard = \"discard\",\n    Think = \"think\",\n};\n\nexport interface Turn {\n    player: number;\n    phase: Phase;\n};\n","export enum Location {\n    Deck = \"deck\",\n    Discard = \"discard\",\n    Center = \"center\",\n    Hand = \"hand\",\n    Win = \"win\",\n};\n\nexport const getLocationSortOrder = (location: Location): number => {\n    switch (location) {\n        case Location.Center:\n            return 0;\n        case Location.Discard:\n            return 1;\n        case Location.Deck:\n            return 2;\n        case Location.Hand:\n            return 3;\n        case Location.Win:\n            return 4;\n    }\n};\n","import { Location } from './Location';\nimport { Position } from './Position';\n\nexport type Card = {\n    id: Readonly<number>;\n\n    color: Readonly<string>;\n    wallpaper: Readonly<string>;\n    decoration: Readonly<string>;\n\n    location: Location;\n    visible: boolean;\n\n    pos: Position;\n\n    // Player index that this card belongs to\n    owner: number | null;\n\n    animating: boolean;\n};\n\nexport const numMatches = (a: Card, b: Card): number => {\n    return (a.color === b.color ? 1 : 0)\n        + (a.wallpaper === b.wallpaper ? 1 : 0)\n        + (a.decoration === b.decoration ? 1 : 0);\n};\n\nexport const cardToString = (card: Card): string => {\n    return `[${card.color},${card.wallpaper},${card.decoration} (${card.id})]`;\n};\n","import { Card } from \"./Card\";\nimport { Location } from \"./Location\";\n\nexport class Deck extends Array<Card> {\n  static create(): Deck {\n    let deck = new Deck();\n\n    const colors = [\"blue\", \"purple\", \"red\"];\n    const wallpapers = [\"flowers\", \"stripes\", \"circles\"];\n    const decorations = [\"clock\", \"painting\", \"plant\"];\n\n    for (let i = 0; i < 2; i++) {\n      colors.forEach((color) => {\n        wallpapers.forEach((wallpaper) => {\n          decorations.forEach((decoration) => {\n            deck.push({\n              id: deck.length,\n              color,\n              wallpaper,\n              decoration,\n              location: Location.Deck,\n              visible: false,\n              pos: { x: 0, y: 0 },\n              owner: null,\n              animating: false,\n            });\n          });\n        });\n      });\n    }\n\n    return deck.shuffle();\n  }\n\n  shuffle(): Deck {\n    let d = new Deck();\n    d.push(\n      ...this.map((value) => ({ value, sort: Math.random() }))\n        .sort((a, b) => a.sort - b.sort)\n        .map(({ value }) => value)\n    );\n\n    return d;\n  }\n}\n","import { Dispatch } from 'react';\nimport { GameState, Action, Actions, getHand, getCenter } from './GameState';\nimport { numMatches } from './Card';\nimport { Phase } from './Turn';\n\nexport type Player = {\n    // Which \"seat\" this player is in at the table\n    seat: number;\n\n    // Display name\n    name: string;\n\n    // What strategy to use while playing (used for bots, mostly)\n    strategy: PlayerStrategy;\n\n    // Number of cards needed to be discarded\n    toDiscard: number;\n};\n\nexport interface PlayerStrategy {\n    isHuman(): boolean;\n\n    // Turn off your mind\n    cancelThoughts(): void;\n\n    // What this player should do when a new card is played\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void;\n\n    // What this player should do when they have to discard cards\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void;\n};\n\nexport class HumanStrategy implements PlayerStrategy {\n    isHuman(): boolean\n    {\n        return true;\n    }\n\n    cancelThoughts(): void\n    {\n        // Do nothing! (Free will?)\n    }\n\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Do nothing!\n    }\n\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Do nothing!\n    }\n}\n\nexport class BotStrategy implements PlayerStrategy {\n    timeout: NodeJS.Timeout | null;\n\n    constructor()\n    {\n        this.timeout = null;\n    }\n\n    isHuman(): boolean\n    {\n        return false; // beep boop beep\n    }\n\n    cancelThoughts(): void\n    {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n        }\n    }\n\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Only handle one operation at a time\n        this.cancelThoughts();\n\n        // Only play a card when you're allowed (other player is thinking or player is playing)\n        if (state.paused || [Phase.Wait, Phase.Discard, Phase.Pregame, Phase.Preround].includes(state.turn.phase)) {\n            return;\n        }\n\n        // Handle the actual logic after \"deciding\"\n        this.timeout = setTimeout(() => {\n            const center = getCenter(state);\n            const hand = getHand(state, player.seat);\n\n            // Play the best match in-hand\n            let bestMatch = 0;\n            let toPlay = -1;\n            for (let i = 0; i < hand.length; i++) {\n                const matches = numMatches(hand[i], center);\n                if (matches > bestMatch) {\n                    bestMatch = matches;\n                    toPlay = hand[i].id;\n                }\n            }\n\n            // Play a card if it's our turn or we have a perfect match\n            if (toPlay !== -1 && (state.turn.player === player.seat || bestMatch === 3)) {\n                dispatch({ type: Actions.PlayCard, payload: { id: toPlay, player: player.seat }});\n            } else if (state.turn.player === player.seat) {\n                // No matches, draw a card\n                dispatch({ type: Actions.Draw, payload: { player: player.seat }});\n            }\n        }, 1000 * getHand(state, player.seat).length);\n\n        if (state.turn.player === player.seat && state.turn.phase !== Phase.Think) {\n            dispatch({ type: Actions.Think, payload: { player: player.seat }});\n        }\n    }\n\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        const hand = getHand(state, player.seat);\n\n        if (player.toDiscard > 0 && hand.length > 0) {\n            dispatch({ \n                type: Actions.DiscardCard, \n                payload: { id: hand[0].id, player: player.seat },\n            })\n        }\n    }\n}\n","import { useState, useEffect } from \"react\";\nimport { Position } from '../types/Position';\n\ninterface Size {\n    width: number;\n    height: number;\n}\n\nexport type DefaultPositions = {\n    deck: Position;\n    center: Position;\n    discard: Position;\n    win: Position;\n    players: Position[];\n};\n\nexport function calculatePositions(size: Size): DefaultPositions {\n    return {\n        deck: {\n            x: size.width / 3 - 225, \n            y: size.height / 3 + 50,\n        },\n        center: {\n            x: (size.width / 2) - 100,\n            y: size.height / 3 + 25,\n        },\n        discard: {\n            x: (size.width / 3) * 2, \n            y: size.height / 3 + 50,\n        },\n        win: { x: -1000, y: -1000},\n        players: [{\n            x: (size.width / 2) - 25,\n            y: size.height - 300,\n        }, {\n            x: (size.width / 3) - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 2 - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 3 - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 4 - (size.width / 5),\n            y: 10,\n        }],\n    };\n}\n\nfunction usePositions(): DefaultPositions {\n    const [windowSize, setWindowSize] = useState<Size>({\n        width: 0,\n        height: 0,\n    });\n    const [positions, setPositions] = useState<DefaultPositions>(calculatePositions(windowSize));\n\n    // Add resize handle on mount\n    useEffect(() => {\n        function handleResize() {\n            setWindowSize({\n                width: window.innerWidth,\n                height: window.innerHeight,\n            });\n        };\n\n        window.addEventListener(\"resize\", handleResize);\n\n        handleResize();\n\n        return () => window.removeEventListener(\"resize\", handleResize);\n    }, []);\n\n    // Calculate our positions whenever the window size changes\n    useEffect(() => {\n        setPositions(calculatePositions(windowSize));\n    }, [windowSize]);\n\n    return positions;\n}\n\nexport default usePositions;\n","import { toast } from \"react-toastify\";\nimport { Card, numMatches, cardToString } from \"./Card\";\nimport { Deck } from \"./Deck\";\nimport { Player, HumanStrategy, BotStrategy } from \"./Player\";\nimport { Turn, Phase } from \"./Turn\";\nimport { Location } from \"./Location\";\nimport { Draft } from \"immer\";\nimport { DefaultPositions, calculatePositions } from \"../util/usePositions\";\n\nexport type GameState = {\n  cards: Deck;\n  center: number; // Card ID that is the current center\n  previousCenter: number; // Card ID that was previously the center\n  players: Player[];\n  turn: Turn;\n  paused: boolean;\n  positions: DefaultPositions;\n};\n\nexport const initialState: GameState = {\n  cards: new Deck(),\n  center: -1,\n  previousCenter: -1,\n  players: [],\n  turn: {\n    player: 0,\n    phase: Phase.Pregame,\n  },\n  paused: false,\n  positions: calculatePositions({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  }),\n};\n\nexport enum Actions {\n  LoadGame = \"LoadGame\",\n  StartGame = \"StartGame\",\n  PauseGame = \"PauseGame\",\n  ResumeGame = \"ResumeGame\",\n  Resize = \"Resize\",\n  Deal = \"Deal\",\n  StartRound = \"StartRound\",\n  PlayCard = \"PlayCard\",\n  DiscardCard = \"DiscardCard\",\n  Draw = \"Draw\",\n  Think = \"Think\",\n  WinRound = \"WinRound\",\n  WinGame = \"WinGame\",\n  FinishAnimation = \"FinishAnimation\",\n}\n\nexport interface StartGamePayload {\n  numHumans: number;\n  numBots: number;\n}\n\nexport interface PlayCardPayload {\n  id: number;\n  player: number;\n}\n\nexport interface CardPayload {\n  id: number;\n}\n\nexport interface PlayerPayload {\n  player: number;\n}\n\nexport type Action =\n  | { type: Actions.LoadGame; payload: GameState }\n  | { type: Actions.StartGame; payload: StartGamePayload }\n  | { type: Actions.PauseGame; payload: null }\n  | { type: Actions.ResumeGame; payload: null }\n  | { type: Actions.Resize; payload: DefaultPositions }\n  | { type: Actions.Deal; payload: null }\n  | { type: Actions.StartRound; payload: null }\n  | { type: Actions.PlayCard; payload: PlayCardPayload }\n  | { type: Actions.DiscardCard; payload: PlayCardPayload }\n  | { type: Actions.Think; payload: PlayerPayload }\n  | { type: Actions.Draw; payload: PlayerPayload }\n  | { type: Actions.WinRound; payload: PlayerPayload }\n  | { type: Actions.FinishAnimation; payload: CardPayload }\n  | { type: Actions.WinGame; payload: PlayerPayload };\n\nexport function reducer(draft: Draft<GameState>, action: Action): void {\n  switch (action.type) {\n    case Actions.LoadGame:\n      draft.cards = new Deck(...action.payload.cards);\n      draft.center = action.payload.center;\n      draft.previousCenter = action.payload.previousCenter;\n      draft.players = action.payload.players;\n      draft.turn = action.payload.turn;\n\n      break;\n\n    case Actions.StartGame:\n      let players = new Array<Player>();\n      for (let i = 0; i < action.payload.numHumans; i++) {\n        players.push({\n          seat: i,\n          name: `You`,\n          strategy: new HumanStrategy(),\n          toDiscard: 0,\n        });\n      }\n\n      for (let i = 0; i < action.payload.numBots; i++) {\n        players.push({\n          seat: i + action.payload.numHumans,\n          name: `Bot ${i + 1}`,\n          strategy: new BotStrategy(),\n          toDiscard: 0,\n        });\n      }\n\n      draft.cards = Deck.create();\n      draft.players = players;\n      draft.turn = {\n        player: Math.floor(Math.random() * players.length),\n        phase: Phase.Preround,\n      };\n      break;\n\n    case Actions.PauseGame:\n      draft.paused = true;\n      break;\n\n    case Actions.ResumeGame:\n      draft.paused = false;\n      break;\n\n    case Actions.Resize:\n      draft.positions = action.payload;\n      draft.cards.map((c) => {\n        switch (c.location) {\n          case Location.Center:\n            c.pos = draft.positions.center;\n            break;\n          case Location.Deck:\n            c.pos = draft.positions.deck;\n            break;\n          case Location.Discard:\n            c.pos = draft.positions.discard;\n            break;\n          case Location.Hand:\n            if (c.owner !== null) {\n              c.pos = draft.positions.players[c.owner];\n            }\n            break;\n        }\n\n        return c;\n      });\n\n      break;\n\n    case Actions.Deal:\n      // 2-3 players = 9 cards, 4 players = 8 cards, 5 players = 7 cards\n      const baseCards = 9 - draft.players.length + 3;\n\n      moveToCenter(\n        draft,\n        draft.cards.find((c) => c.location === Location.Deck) as Card,\n        false\n      );\n\n      for (let seat = 0; seat < draft.players.length; seat++) {\n        for (let i = 0; i < baseCards + numWins(draft, seat); i++) {\n          dealCard(draft, seat);\n        }\n      }\n\n      draft.turn.phase = Phase.Wait;\n      break;\n\n    case Actions.StartRound:\n      draft.cards.filter((c) => c.id === draft.center)[0].visible = true;\n      draft.turn.phase = Phase.Play;\n      break;\n\n    case Actions.PlayCard: {\n      const playedCard = getCard(draft, action.payload.id);\n      const center = getCard(draft, draft.center);\n      if (playedCard && center) {\n        const matches = numMatches(center, playedCard);\n        console.log(\n          `${draft.players[action.payload.player].name} played ${cardToString(\n            playedCard\n          )}. It has ${matches} matches on ${cardToString(center)}`\n        );\n\n        // On turn play\n        if (draft.turn.player === action.payload.player && matches > 0) {\n          moveToCenter(draft, playedCard, true);\n\n          if (matches - 1 > 0) {\n            draft.turn.phase = Phase.Discard;\n            draft.players[draft.turn.player].toDiscard = matches - 1;\n          } else {\n            draft.turn.player++;\n            if (draft.turn.player >= draft.players.length) {\n              draft.turn.player = 0;\n            }\n            draft.turn.phase = Phase.Play;\n          }\n        } else if (\n          draft.turn.player !== action.payload.player &&\n          matches === 3\n        ) {\n          toast(\"Perfect Match!\", { toastId: \"perfect-match\" });\n\n          // Perfect match, off turn\n          moveToCenter(draft, playedCard, true);\n\n          // Switch to perfectly played player's turn\n          draft.turn.player = action.payload.player;\n          draft.turn.phase = Phase.Play;\n        } else if (action.payload.player === 0) {\n          // No match! (Do something?)\n          toast.error(\"That card has no matches!\", { toastId: \"rejected\" });\n        }\n      }\n\n      break;\n    }\n\n    case Actions.DiscardCard: {\n      const playedCard = getCard(draft, action.payload.id);\n\n      if (playedCard) {\n        moveToDiscard(draft, playedCard);\n\n        draft.players[draft.turn.player].toDiscard--;\n        console.log(\n          `${draft.players[action.payload.player].name} discarded a card.`\n        );\n\n        if (draft.players[draft.turn.player].toDiscard <= 0) {\n          draft.turn.player++;\n          if (draft.turn.player >= draft.players.length) {\n            draft.turn.player = 0;\n          }\n          draft.turn.phase = Phase.Play;\n        }\n      }\n\n      break;\n    }\n\n    case Actions.Think:\n      if (draft.turn.player === action.payload.player) {\n        draft.turn.phase = Phase.Think;\n      }\n      break;\n\n    case Actions.Draw:\n      // Shuffle the discard pile back into the draw pile when it runs out\n      if (\n        draft.cards.filter((c) => c.location === Location.Deck).length === 0\n      ) {\n        draft.cards.map((c) => {\n          if (c.location === Location.Discard) {\n            c.location = Location.Deck;\n            c.pos = draft.positions.deck;\n            c.animating = true;\n          }\n\n          return c;\n        });\n      }\n\n      if (draft.turn.player === action.payload.player) {\n        dealCard(draft, draft.turn.player);\n      }\n      break;\n\n    case Actions.WinRound:\n      toast(`${draft.players[action.payload.player].name} won the round!`, {\n        toastId: \"win-round\",\n      });\n\n      moveToWin(\n        draft,\n        draft.cards.find((c) => c.location !== Location.Win) as Card,\n        action.payload.player\n      );\n      resetRound(draft, action.payload.player);\n\n      break;\n\n    case Actions.WinGame:\n      moveToWin(\n        draft,\n        draft.cards.find((c) => c.location !== Location.Win) as Card,\n        action.payload.player\n      );\n      draft.turn.phase = Phase.Postgame;\n\n      break;\n\n    case Actions.FinishAnimation:\n      const card = getCard(draft, action.payload.id);\n      if (card) {\n        card.animating = false;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown action ${JSON.stringify(action)}`);\n  }\n}\n\nfunction getCard(draft: Draft<GameState>, id: number): Card | undefined {\n  return draft.cards.find((c) => c.id === id);\n}\n\nfunction moveToCenter(\n  draft: Draft<GameState>,\n  card: Card,\n  visible: boolean\n): void {\n  draft.previousCenter = draft.center;\n\n  card.location = Location.Center;\n  card.pos = draft.positions.center;\n  card.visible = visible;\n  card.owner = null;\n  card.animating = true;\n\n  draft.center = card.id;\n}\n\nfunction moveToDiscard(draft: Draft<GameState>, card: Card): void {\n  card.location = Location.Discard;\n  card.pos = draft.positions.discard;\n  card.visible = false;\n  card.owner = null;\n  card.animating = true;\n}\n\nfunction resetRound(draft: Draft<GameState>, lastWinner: number) {\n  draft.cards.map((c) => {\n    if (c.location !== Location.Win) {\n      c.location = Location.Deck;\n      c.pos = draft.positions.deck;\n      c.visible = false;\n      c.owner = null;\n      c.animating = true;\n    }\n\n    return c;\n  });\n  draft.cards = draft.cards.shuffle();\n\n  draft.turn = {\n    player: lastWinner + 1,\n    phase: Phase.Preround,\n  };\n  if (draft.turn.player >= draft.players.length) {\n    draft.turn.player = 0;\n  }\n\n  draft.players.forEach((player) => (player.toDiscard = 0));\n}\n\nfunction numWins(draft: Draft<GameState>, seat: number): number {\n  return draft.cards.filter(\n    (c) => c.owner === seat && c.location === Location.Win\n  ).length;\n}\n\nfunction dealCard(draft: Draft<GameState>, seat: number): void {\n  let card = draft.cards.find((c) => c.location === Location.Deck);\n\n  if (card) {\n    card.pos = draft.positions.players[seat];\n    card.location = Location.Hand;\n    card.owner = seat;\n    card.visible = draft.players[seat].strategy.isHuman();\n    card.animating = true;\n  }\n}\n\nfunction moveToWin(draft: Draft<GameState>, card: Card, seat: number): void {\n  card.pos = draft.positions.win;\n  card.location = Location.Win;\n  card.owner = seat;\n  card.visible = false;\n}\n\nexport const getCenter = (state: GameState): Card =>\n  state.cards.filter((c) => c.id === state.center)[0];\n\nexport const getHand = (state: GameState, player: number): Card[] =>\n  state.cards.filter((c) => c.owner === player && c.location === Location.Hand);\n\nexport const getRoundWinner = (state: GameState): number | undefined => {\n  if (state.turn.phase === Phase.Preround) {\n    return undefined;\n  }\n\n  return state.players\n    .map((p) => ({ seat: p.seat, handSize: getHand(state, p.seat).length }))\n    .filter((p) => p.handSize === 0)\n    .map((p) => p.seat)\n    .shift();\n};\n\nexport const getGameWinner = (state: GameState): number | undefined => {\n  return state.players\n    .map((p) => ({\n      seat: p.seat,\n      handSize: getHand(state, p.seat).length,\n      wins: numWins(state, p.seat),\n    }))\n    .filter((p) => p.wins >= 3)\n    .map((p) => p.seat)\n    .shift();\n};\n\nexport const animationRunning = (state: GameState): boolean =>\n  state.cards.filter((c) => c.animating === true).length > 0;\n","import { useEffect, Dispatch } from 'react'\nimport { useImmerReducer } from 'use-immer';\nimport { reducer, initialState, getCenter, getRoundWinner, GameState, Action, Actions, animationRunning, getGameWinner } from '../types/GameState';\nimport { Phase } from '../types/Turn';\nimport { HumanStrategy, BotStrategy } from '../types/Player';\nimport usePositions, { DefaultPositions } from './usePositions';\n\nconst useGameState = (): { state: GameState, dispatch: Dispatch<Action>, positions: DefaultPositions } => {\n    const [state, dispatch] = useImmerReducer(reducer, initialState);\n    const positions = usePositions();\n\n    // Try to save/load the state from localstorage\n    useEffect(() => {\n        // Try to pull state from localstorage and only populate if we don't already have a state in memory\n        const gameData = window.localStorage.getItem('gameData')\n        if (gameData !== null && state === initialState) {\n            dispatch({ type: Actions.LoadGame, payload: JSON.parse(gameData, (key, value) => {\n                if (key === 'strategy') {\n                    return value === 'HumanStrategy' ? new HumanStrategy() : new BotStrategy();\n                }\n\n                return value;\n            })});\n        }\n\n        // Save state to localstorage if we have a state to save\n        if (state !== initialState) {\n            window.localStorage.setItem('gameData', JSON.stringify(state, (key, value) => {\n                if (key === 'strategy') {\n                    return value.timeout === undefined ? 'HumanStrategy' : 'BotStrategy';\n                }\n\n                return value;\n            }));\n        }\n    // eslint-disable-next-line\n    }, [state]);\n\n    // Update bots whenever state changes\n    useEffect(() => {\n        // No bot actions before/after the game/round starts or if there are active animations\n        if (state === initialState \n            || state.paused\n            || [Phase.Pregame, Phase.Preround, Phase.Postgame].includes(state.turn.phase) \n            || animationRunning(state)\n        ) {\n            return;\n        }\n\n        // Check for a round win\n        const roundWinner = getRoundWinner(state);\n        if (typeof roundWinner !== 'undefined') {\n            state.players.forEach((player) => player.strategy.cancelThoughts());\n\n            // Check for a game win\n            const gameWinner = getGameWinner(state);\n            if (typeof gameWinner !== 'undefined') {\n                dispatch({ type: Actions.WinGame, payload: { player: gameWinner }});\n            } else {\n                dispatch({ type: Actions.WinRound, payload: { player: roundWinner }});\n            }\n\n            return;\n        }\n\n        const center = getCenter(state);\n        let centerChanged = false;\n        if (center && center.visible && center.id !== state.previousCenter) {\n            centerChanged = true;\n        }\n\n        // Only allow a bot to play a card when the center card changes or when it's their turn\n        state.players.forEach((player) => {\n            if (state.turn.player === player.seat || centerChanged) {\n                player.strategy.onCardPlayed(player, state, dispatch)\n            }\n        });\n\n        // Only discard when you need to discard\n        state.players.forEach((player) => player.strategy.onDiscardNeeded(player, state, dispatch));\n    // eslint-disable-next-line\n    }, [state]);\n\n    useEffect(() => {\n        dispatch({ type: Actions.Resize, payload: positions });\n    // eslint-disable-next-line\n    }, [positions]);\n\n    return {\n        state,\n        dispatch,\n        positions,\n    };\n}\n\nexport default useGameState;\n","import React, { FC, CSSProperties, Dispatch, useEffect } from 'react';\nimport { Action, Actions } from '../types/GameState';\nimport { Card as CardModel } from '../types/Card';\nimport { Turn, Phase } from '../types/Turn';\n\nimport './Card.scss'\n\ntype CardProps = CardModel & {\n    dispatch: Dispatch<Action>;\n    turn: Turn;\n    index: number;\n}\n\nconst Card: FC<CardProps> = ({ index, id, color, wallpaper, decoration, visible, location, pos, owner, dispatch, turn, animating }) => {\n    useEffect(() => {\n        if (animating === true) {\n            setTimeout(() => dispatch({ type: Actions.FinishAnimation, payload: { id }}), 1000);\n        }\n    // eslint-disable-next-line\n    }, [id, animating, location])\n\n    const imageClass = visible\n        ? `${color}_${wallpaper}_${decoration}`\n        : `cardback`;\n\n    let style: CSSProperties = {\n        top: `${pos.y}px`,\n        left: `${pos.x}px`,\n        zIndex: index,\n    };\n\n    return (\n        <div\n            id={`card${id}`}\n            className={`card ${imageClass} ${visible ? 'front' : 'back'} ${location} ${owner ? `p${owner}` : ''}`}\n            style={style}\n            onClick={() => {\n                // Only human playable cards\n                if (owner === 0) {\n                    if (turn.player === 0 && turn.phase === Phase.Play) {\n                        // On turn\n                        dispatch({ type: Actions.PlayCard, payload: { id, player: 0 }})\n                    } else if (turn.player !== 0 && [Phase.Think, Phase.Play].includes(turn.phase)) {\n                        // Off turn perfect match\n                        dispatch({ type: Actions.PlayCard, payload: { id, player: 0 }})\n                    } else if (turn.player === 0 && turn.phase === Phase.Discard) {\n                        // Discard\n                        dispatch({ type: Actions.DiscardCard, payload: { id, player: 0 }})\n                    }\n                }\n            }}\n        />\n    )\n}\n\nexport default Card;\n","export default __webpack_public_path__ + \"static/media/title.ba82babd.png\";","export default __webpack_public_path__ + \"static/media/rules-matching.2efc1db4.png\";","export default __webpack_public_path__ + \"static/media/rules-discards.fa4adcf7.png\";","export default __webpack_public_path__ + \"static/media/rules-perfect-match.ce102ae8.png\";","import React, { Dispatch, FC, useState, Fragment } from \"react\";\nimport { Actions, Action } from \"../types/GameState\";\n\nimport \"./Rules.scss\";\n\nimport title from \"../img/title.png\";\nimport matching from \"../img/rules-matching.png\";\nimport discards from \"../img/rules-discards.png\";\nimport perfect from \"../img/rules-perfect-match.png\";\n\ninterface RulesProps {\n  dispatch: Dispatch<Action>;\n  resume: boolean;\n}\n\nconst Rules: FC<RulesProps> = ({ dispatch, resume }) => {\n  const [page, setPage] = useState(0);\n\n  let instructions = <Fragment />;\n  switch (page) {\n    case 0:\n      instructions = (\n        <Fragment>\n          <p>\n            Compete with your fellow interior designers to suggest ideas for how\n            this nook should look.\n          </p>\n          <img src={title} alt=\"Nook title\" />\n          <p>\n            Illustrations by{\" \"}\n            <a\n              href=\"https://twitter.com/Remuvou2\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              Remugade\n            </a>\n          </p>\n        </Fragment>\n      );\n      break;\n\n    case 1:\n      instructions = (\n        <Fragment>\n          <p>\n            Play cards from your hand to create matches with the card in the\n            center.\n          </p>\n          <img src={matching} alt=\"Rules on matching\" />\n        </Fragment>\n      );\n      break;\n\n    case 2:\n      instructions = (\n        <Fragment>\n          <p>\n            The better the match, the more cards you can discard. Discard your\n            hand first to win the round.\n          </p>\n          <img src={discards} alt=\"Rules on discarding\" />\n        </Fragment>\n      );\n      break;\n\n    case 3:\n      instructions = (\n        <Fragment>\n          <p>\n            You can also play a perfect match at any time &mdash; even when it's\n            not your turn. If you do, it'll become your turn immediately!\n          </p>\n          <img src={perfect} alt=\"Rules on perfect matches\" />\n        </Fragment>\n      );\n      break;\n\n    case 4:\n      instructions = (\n        <Fragment>\n          <p>\n            Be the first designer to empty your hand and you'll win the round!\n            Win 3 rounds and you'll win the game. Good Luck!\n          </p>\n        </Fragment>\n      );\n      break;\n  }\n\n  return (\n    <div className=\"rules\">\n      <h1>nook</h1>\n\n      <div className=\"instructions-box\">\n        {instructions}\n\n        <div className=\"instruction-page-buttons\">\n          <button onClick={() => setPage(page - 1)} disabled={page === 0}>\n            &larr;\n          </button>\n\n          <button onClick={() => setPage(page + 1)} disabled={page === 4}>\n            &rarr;\n          </button>\n        </div>\n      </div>\n\n      <div className=\"buttons\">\n        <button\n          className={page === 4 ? \"highlight\" : \"\"}\n          onClick={() => {\n            dispatch({\n              type: Actions.StartGame,\n              payload: { numHumans: 1, numBots: 3 },\n            });\n            dispatch({ type: Actions.ResumeGame, payload: null });\n          }}\n        >\n          New Game\n        </button>\n\n        <button\n          className={page === 4 ? \"highlight\" : \"\"}\n          onClick={() => {\n            resume\n              ? dispatch({ type: Actions.ResumeGame, payload: null })\n              : dispatch({\n                  type: Actions.StartGame,\n                  payload: { numHumans: 1, numBots: 3 },\n                });\n          }}\n        >\n          {resume ? \"Resume\" : \"Start\"} Game\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Rules;\n","import React, { FC, Dispatch, Fragment } from \"react\";\nimport { GameState, Action, Actions } from \"../types/GameState\";\nimport { Phase } from \"../types/Turn\";\n\nimport \"./TurnTracker.scss\";\n\ntype TurnTrackerProps = GameState & {\n  dispatch: Dispatch<Action>;\n};\n\nconst TurnTracker: FC<TurnTrackerProps> = ({\n  players,\n  turn,\n  dispatch,\n  positions,\n}) => {\n  return (\n    <div className={`turn-tracker ${turn.phase}`}>\n      {turn.phase === Phase.Preround ? (\n        <button onClick={() => dispatch({ type: Actions.Deal, payload: null })}>\n          Deal\n        </button>\n      ) : (\n        <Fragment />\n      )}\n\n      {turn.phase === Phase.Wait ? (\n        <button\n          onClick={() => dispatch({ type: Actions.StartRound, payload: null })}\n        >\n          Ready?\n        </button>\n      ) : (\n        <Fragment />\n      )}\n\n      {[Phase.Play, Phase.Discard, Phase.Think].includes(turn.phase) ? (\n        <Fragment>\n          <span>\n            {turn.player === 0 ? \"Your\" : `${players[turn.player].name}'s`} Turn\n          </span>\n          <span>\n            (\n            {turn.player === 0\n              ? `${turn.phase} ${\n                  players[turn.player].toDiscard > 0\n                    ? `${players[turn.player].toDiscard} `\n                    : \"a \"\n                }card${players[turn.player].toDiscard > 1 ? \"s\" : \"\"}`\n              : `${turn.phase}ing...`}\n            )\n          </span>\n        </Fragment>\n      ) : (\n        <Fragment />\n      )}\n    </div>\n  );\n};\n\nexport default TurnTracker;\n","import React, { FC, Fragment } from 'react';\nimport { GameState } from '../types/GameState';\nimport { Location } from '../types/Location';\nimport { Phase } from '../types/Turn';\n\nimport './HandStats.scss';\n\n\ntype HandStatsProps = GameState & {\n    seat: number;\n};\n\nconst HandStats: FC<HandStatsProps> = ({ cards, players, turn, seat, positions }) => {\n    if ([Phase.Pregame].includes(turn.phase)) {\n        return <Fragment />;\n    }\n\n    const handSize = cards.filter((c) => c.owner === seat && c.location === Location.Hand).length;\n    const wins = cards.filter((c) => c.owner === seat && c.location === Location.Win).length;\n    const isAfterFirstRound = cards.filter((c) => c.location === Location.Deck).length !== cards.length;\n    let previousPlayer = turn.player - 1;\n    if (previousPlayer === -1) {\n        previousPlayer = players.length - 1;\n    }\n\n    let icon = <Fragment />;\n    if (turn.player === seat && turn.phase === Phase.Think) {\n        icon = <span className=\"icon\">🤔</span>;\n    } else if (turn.phase === Phase.Preround && isAfterFirstRound && seat !== 0) {\n        if (previousPlayer === seat) {\n            icon = <span className=\"icon\">😁</span>;\n        } else {\n            icon = <span className=\"icon\">😒</span>;\n        }\n    }\n\n    const style = {\n        top: `${positions.players[seat].y + 200}px`, \n        left: `${positions.players[seat].x - 100}px`,\n    }\n\n    return (\n        <div className={`hand-stats ${turn.player === seat ? 'highlight' : ''}`} style={style}>\n            <span className=\"bold\">{players[seat].name}</span>\n            <span>Hand: {handSize}</span>\n            <span>Wins: {wins}</span>\n            {icon}\n        </div>\n    )\n};\n\nexport default HandStats;\n","import React, { FC, Dispatch, Fragment } from 'react';\nimport { Action, Actions } from '../types/GameState';\n\nimport Rules from './Rules';\n\nimport './HelpButton.scss';\n\ntype HelpButtonProps = {\n    dispatch: Dispatch<Action>,\n    paused: boolean,\n};\n\nconst HelpButton: FC<HelpButtonProps> = ({ dispatch, paused }) => {\n\n    return ( \n        <Fragment>\n            {paused && <Rules dispatch={dispatch} resume={true} />}\n            <button \n                className=\"help-button\" \n                onClick={() => {\n                    paused\n                        ? dispatch({ type: Actions.ResumeGame, payload: null })\n                        : dispatch({ type: Actions.PauseGame, payload: null });\n                }}>&#8264;</button>\n        </Fragment>\n    )\n};\n\nexport default HelpButton;\n","import React, { FC, Dispatch, Fragment, CSSProperties } from \"react\";\nimport { GameState, Action, Actions } from \"../types/GameState\";\nimport { Position } from \"../types/Position\";\nimport { Phase } from \"../types/Turn\";\n\ntype DrawCardButtonProps = GameState & {\n  dispatch: Dispatch<Action>;\n  pos: Position;\n};\n\nconst DrawCardButton: FC<DrawCardButtonProps> = ({ turn, dispatch, pos }) => {\n  const style: CSSProperties = {\n    position: \"relative\",\n    top: `${pos.y + 110}px`,\n    left: `${pos.x}px`,\n    zIndex: 999,\n  };\n\n  return turn.player === 0 && turn.phase === Phase.Play ? (\n    <button\n      style={style}\n      onClick={() => dispatch({ type: Actions.Draw, payload: { player: 0 } })}\n    >\n      Draw\n    </button>\n  ) : (\n    <Fragment />\n  );\n};\n\nexport default DrawCardButton;\n","import React, { Dispatch, FC } from 'react';\nimport { GameState, Actions, Action, getGameWinner } from '../types/GameState';\n\nimport './OffBoarding.scss';\n\ninterface OffBoardingProps {\n    state: GameState;\n    dispatch: Dispatch<Action>;\n}\n\nconst OffBoarding: FC<OffBoardingProps> = ({ state, dispatch }) => {\n    const winner = getGameWinner(state) || 0;\n\n    return (\n        <div className=\"offboarding\">\n            <h1>{state.players[winner].name} win{winner === 0 ? '' : 's'}!</h1>\n            <p>Thanks for playing nook!</p>\n            <p>\n                Please fill out this&nbsp;\n                <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfelrfR0elf49pKwpVmCrPzMz5f5rcwJd3TKnu13Rfc4Ajm_w/viewform?usp=sf_link\" target=\"_blank\" rel=\"noopener noreferrer\">survey</a>\n                &nbsp;with your thoughts on the game. I really appreciate it!\n            </p>\n\n            <p>\n                <button\n                    onClick={() => dispatch({ type: Actions.StartGame, payload: { numHumans: 1, numBots: 3 } })}\n                >\n                    Play Again?\n                </button>\n            </p>\n        </div>\n    )\n}\n\nexport default OffBoarding\n","import React, { useMemo, Fragment } from 'react';\nimport { Phase } from './types/Turn';\nimport { getLocationSortOrder } from './types/Location';\nimport useGameState from './util/useGameState';\n\nimport Card from './components/Card';\nimport Rules from './components/Rules';\nimport TurnTracker from './components/TurnTracker';\nimport HandStats from './components/HandStats';\nimport HelpButton from './components/HelpButton';\nimport DrawCardButton from './components/DrawCardButton';\nimport OffBoarding from './components/OffBoarding';\n\nimport './App.scss'\n\n\nfunction App() {\n  const { state, dispatch, positions } = useGameState();\n\n  const cards = useMemo(() => \n    state.cards.map((c) => ({ c, sort: getLocationSortOrder(c.location) + (c.owner ? c.owner : 0) })),\n    [state.cards]\n  );\n\n  if (state.turn.phase === Phase.Pregame) {\n    return <Rules dispatch={dispatch} resume={false} />\n  }\n\n  if (state.turn.phase === Phase.Postgame) {\n    return <OffBoarding state={state} dispatch={dispatch} />\n  }\n\n  return (\n    <div className=\"App\">\n      {!state.paused && (\n        <Fragment>\n          <TurnTracker {...state} dispatch={dispatch} />\n\n          {state.players.map((p, i) => (\n            <HandStats key={`hand-${i}`} {...state} seat={p.seat} />\n          ))}\n\n          {cards.map(({ c, sort }) => (\n            <Card\n              key={c.id}\n              {...c}\n              index={state.center === c.id ? 200 : (state.previousCenter === c.id ? 100 : sort)}\n              dispatch={dispatch}\n              turn={state.turn}\n            />\n          ))}\n\n          <DrawCardButton {...state} dispatch={dispatch} pos={positions.deck} />\n        </Fragment>\n      )}\n\n      <HelpButton dispatch={dispatch} paused={state.paused} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ToastContainer } from 'react-toastify';\n\nimport App from './App';\n\nimport './index.css';\nimport 'react-toastify/dist/ReactToastify.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ToastContainer\n      position=\"top-center\"\n      autoClose={3000}\n      hideProgressBar\n      newestOnTop={false}\n      closeOnClick={false}\n      closeButton={false}\n      rtl={false}\n      pauseOnFocusLoss={false}\n      draggable={false}\n      pauseOnHover={false}\n      className=\"toaster\"\n      toastClassName=\"info\"\n    />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}