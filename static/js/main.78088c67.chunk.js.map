{"version":3,"sources":["types/Turn.ts","types/Location.ts","types/Card.ts","types/Deck.ts","types/Player.ts","util/usePositions.ts","types/GameState.ts","util/useGameState.ts","components/Card.tsx","img/title.png","img/rules-matching.png","img/rules-discards.png","img/rules-perfect-match.png","components/Rules.tsx","components/TurnTracker.tsx","components/HandStats.tsx","components/HelpButton.tsx","components/DrawCardButton.tsx","components/OffBoarding.tsx","App.tsx","index.tsx"],"names":["Phase","Location","getLocationSortOrder","location","Center","Discard","Deck","Hand","Win","numMatches","a","b","color","wallpaper","decoration","cardToString","card","id","d","push","this","map","value","sort","Math","random","deck","colors","wallpapers","decorations","i","forEach","length","visible","pos","x","y","owner","animating","shuffle","Array","HumanStrategy","player","state","dispatch","BotStrategy","timeout","clearTimeout","cancelThoughts","paused","Wait","Pregame","Preround","includes","turn","phase","setTimeout","center","getCenter","hand","getHand","seat","bestMatch","toPlay","matches","type","Actions","Draw","payload","PlayCard","Think","toDiscard","DiscardCard","calculatePositions","size","width","height","discard","win","players","usePositions","useState","windowSize","setWindowSize","positions","setPositions","useEffect","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","initialState","cards","previousCenter","reducer","draft","action","LoadGame","StartGame","numHumans","name","strategy","numBots","create","floor","PauseGame","ResumeGame","Resize","c","Deal","baseCards","moveToCenter","find","numWins","dealCard","StartRound","filter","Play","playedCard","getCard","console","log","toast","toastId","error","moveToDiscard","WinRound","moveToWin","lastWinner","resetRound","WinGame","Postgame","FinishAnimation","Error","JSON","stringify","isHuman","useGameState","useImmerReducer","gameData","localStorage","getItem","parse","key","setItem","undefined","animationRunning","roundWinner","p","handSize","shift","getRoundWinner","centerChanged","onCardPlayed","onDiscardNeeded","gameWinner","wins","getGameWinner","Card","index","imageClass","style","top","left","zIndex","className","onClick","Rules","resume","page","setPage","instructions","src","title","alt","matching","discards","perfect","disabled","TurnTracker","HandStats","isAfterFirstRound","icon","HelpButton","DrawCardButton","position","OffBoarding","App","useMemo","ReactDOM","render","StrictMode","autoClose","hideProgressBar","newestOnTop","closeOnClick","closeButton","rtl","pauseOnFocusLoss","draggable","pauseOnHover","toastClassName","document","getElementById"],"mappings":"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","file":"static/js/main.78088c67.chunk.js","sourcesContent":["export enum Phase {\n    Pregame = \"pregame\",\n    Preround = \"preround\",\n    Postgame = \"postgame\",\n    Wait = \"wait\",\n    Play = \"play\",\n    Discard = \"discard\",\n    Think = \"think\",\n};\n\nexport interface Turn {\n    player: number;\n    phase: Phase;\n};\n","export enum Location {\n    Deck = \"deck\",\n    Discard = \"discard\",\n    Center = \"center\",\n    Hand = \"hand\",\n    Win = \"win\",\n};\n\nexport const getLocationSortOrder = (location: Location): number => {\n    switch (location) {\n        case Location.Center:\n            return 0;\n        case Location.Discard:\n            return 1;\n        case Location.Deck:\n            return 2;\n        case Location.Hand:\n            return 3;\n        case Location.Win:\n            return 4;\n    }\n};\n","import { Location } from './Location';\nimport { Position } from './Position';\n\nexport type Card = {\n    id: Readonly<number>;\n\n    color: Readonly<string>;\n    wallpaper: Readonly<string>;\n    decoration: Readonly<string>;\n\n    location: Location;\n    visible: boolean;\n\n    pos: Position;\n\n    // Player index that this card belongs to\n    owner: number | null;\n\n    animating: boolean;\n};\n\nexport const numMatches = (a: Card, b: Card): number => {\n    return (a.color === b.color ? 1 : 0)\n        + (a.wallpaper === b.wallpaper ? 1 : 0)\n        + (a.decoration === b.decoration ? 1 : 0);\n};\n\nexport const cardToString = (card: Card): string => {\n    return `[${card.color},${card.wallpaper},${card.decoration} (${card.id})]`;\n};\n","import { Card } from './Card';\nimport { Location } from './Location';\n\nexport class Deck extends Array<Card>\n{\n    static create(): Deck\n    {\n        let deck = new Deck();\n\n        const colors = ['blue', 'grey', 'red'];\n        const wallpapers = ['flower', 'stripes', 'chevron'];\n        const decorations = ['clock', 'picture', 'plant'];\n\n        for (let i = 0; i < 2; i++) {\n            colors.forEach((color) => {\n                wallpapers.forEach((wallpaper) => {\n                    decorations.forEach((decoration) => {\n                        deck.push({\n                            id: deck.length,\n                            color,\n                            wallpaper,\n                            decoration,\n                            location: Location.Deck,\n                            visible: false,\n                            pos: { x: 0, y: 0 },\n                            owner: null,\n                            animating: false,\n                        });\n                    });\n                });\n            });\n        }\n\n        return deck.shuffle();\n    }\n\n    shuffle(): Deck\n    {\n        let d = new Deck();\n        d.push(\n            ...this.map((value) => ({ value, sort: Math.random() }))\n                .sort((a, b) => a.sort - b.sort)\n                .map(({ value }) => value)\n        );\n\n        return d;\n    }\n};\n","import { Dispatch } from 'react';\nimport { GameState, Action, Actions, getHand, getCenter } from './GameState';\nimport { numMatches } from './Card';\nimport { Phase } from './Turn';\n\nexport type Player = {\n    // Which \"seat\" this player is in at the table\n    seat: number;\n\n    // Display name\n    name: string;\n\n    // What strategy to use while playing (used for bots, mostly)\n    strategy: PlayerStrategy;\n\n    // Number of cards needed to be discarded\n    toDiscard: number;\n};\n\nexport interface PlayerStrategy {\n    isHuman(): boolean;\n\n    // Turn off your mind\n    cancelThoughts(): void;\n\n    // What this player should do when a new card is played\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void;\n\n    // What this player should do when they have to discard cards\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void;\n};\n\nexport class HumanStrategy implements PlayerStrategy {\n    isHuman(): boolean\n    {\n        return true;\n    }\n\n    cancelThoughts(): void\n    {\n        // Do nothing! (Free will?)\n    }\n\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Do nothing!\n    }\n\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Do nothing!\n    }\n}\n\nexport class BotStrategy implements PlayerStrategy {\n    timeout: NodeJS.Timeout | null;\n\n    constructor()\n    {\n        this.timeout = null;\n    }\n\n    isHuman(): boolean\n    {\n        return false; // beep boop beep\n    }\n\n    cancelThoughts(): void\n    {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n        }\n    }\n\n    onCardPlayed(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        // Only handle one operation at a time\n        this.cancelThoughts();\n\n        // Only play a card when you're allowed (other player is thinking or player is playing)\n        if (state.paused || [Phase.Wait, Phase.Discard, Phase.Pregame, Phase.Preround].includes(state.turn.phase)) {\n            return;\n        }\n\n        // Handle the actual logic after \"deciding\"\n        this.timeout = setTimeout(() => {\n            const center = getCenter(state);\n            const hand = getHand(state, player.seat);\n\n            // Play the best match in-hand\n            let bestMatch = 0;\n            let toPlay = -1;\n            for (let i = 0; i < hand.length; i++) {\n                const matches = numMatches(hand[i], center);\n                if (matches > bestMatch) {\n                    bestMatch = matches;\n                    toPlay = hand[i].id;\n                }\n            }\n\n            // Play a card if it's our turn or we have a perfect match\n            if (toPlay !== -1 && (state.turn.player === player.seat || bestMatch === 3)) {\n                dispatch({ type: Actions.PlayCard, payload: { id: toPlay, player: player.seat }});\n            } else if (state.turn.player === player.seat) {\n                // No matches, draw a card\n                dispatch({ type: Actions.Draw, payload: { player: player.seat }});\n            }\n        }, 1000 * getHand(state, player.seat).length);\n\n        if (state.turn.player === player.seat && state.turn.phase !== Phase.Think) {\n            dispatch({ type: Actions.Think, payload: { player: player.seat }});\n        }\n    }\n\n    onDiscardNeeded(player: Player, state: GameState, dispatch: Dispatch<Action>): void\n    {\n        const hand = getHand(state, player.seat);\n\n        if (player.toDiscard > 0 && hand.length > 0) {\n            dispatch({ \n                type: Actions.DiscardCard, \n                payload: { id: hand[0].id, player: player.seat },\n            })\n        }\n    }\n}\n","import { useState, useEffect } from \"react\";\nimport { Position } from '../types/Position';\n\ninterface Size {\n    width: number;\n    height: number;\n}\n\nexport type DefaultPositions = {\n    deck: Position;\n    center: Position;\n    discard: Position;\n    win: Position;\n    players: Position[];\n};\n\nexport function calculatePositions(size: Size): DefaultPositions {\n    return {\n        deck: {\n            x: size.width / 3 - 225, \n            y: size.height / 3 + 50,\n        },\n        center: {\n            x: (size.width / 2) - 100,\n            y: size.height / 3 + 25,\n        },\n        discard: {\n            x: (size.width / 3) * 2, \n            y: size.height / 3 + 50,\n        },\n        win: { x: -1000, y: -1000},\n        players: [{\n            x: (size.width / 2) - 25,\n            y: size.height - 300,\n        }, {\n            x: (size.width / 3) - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 2 - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 3 - (size.width / 5),\n            y: 10,\n        }, {\n            x: (size.width / 3) * 4 - (size.width / 5),\n            y: 10,\n        }],\n    };\n}\n\nfunction usePositions(): DefaultPositions {\n    const [windowSize, setWindowSize] = useState<Size>({\n        width: 0,\n        height: 0,\n    });\n    const [positions, setPositions] = useState<DefaultPositions>(calculatePositions(windowSize));\n\n    // Add resize handle on mount\n    useEffect(() => {\n        function handleResize() {\n            setWindowSize({\n                width: window.innerWidth,\n                height: window.innerHeight,\n            });\n        };\n\n        window.addEventListener(\"resize\", handleResize);\n\n        handleResize();\n\n        return () => window.removeEventListener(\"resize\", handleResize);\n    }, []);\n\n    // Calculate our positions whenever the window size changes\n    useEffect(() => {\n        setPositions(calculatePositions(windowSize));\n    }, [windowSize]);\n\n    return positions;\n}\n\nexport default usePositions;\n","import { toast } from 'react-toastify';\nimport { Card, numMatches, cardToString } from './Card';\nimport { Deck } from './Deck';\nimport { Player, HumanStrategy, BotStrategy } from './Player';\nimport { Turn, Phase } from './Turn'\nimport { Location } from './Location';\nimport { Draft } from 'immer';\nimport { DefaultPositions, calculatePositions } from '../util/usePositions';\n\nexport type GameState = {\n    cards: Deck;\n    center: number; // Card ID that is the current center\n    previousCenter: number; // Card ID that was previously the center\n    players: Player[];\n    turn: Turn;\n    paused: boolean;\n    positions: DefaultPositions;\n};\n\nexport const initialState: GameState = {\n    cards: new Deck(),\n    center: -1,\n    previousCenter: -1,\n    players: [],\n    turn: {\n        player: 0,\n        phase: Phase.Pregame,\n    },\n    paused: false,\n    positions: calculatePositions({ width: window.innerWidth, height: window.innerHeight }),\n};\n\nexport enum Actions {\n    LoadGame = \"LoadGame\",\n    StartGame = \"StartGame\",\n    PauseGame = \"PauseGame\",\n    ResumeGame = \"ResumeGame\",\n    Resize = \"Resize\",\n    Deal = \"Deal\",\n    StartRound = \"StartRound\",\n    PlayCard = \"PlayCard\",\n    DiscardCard = \"DiscardCard\",\n    Draw = \"Draw\",\n    Think = \"Think\",\n    WinRound = \"WinRound\",\n    WinGame = \"WinGame\",\n    FinishAnimation = \"FinishAnimation\",\n};\n\nexport interface StartGamePayload {\n    numHumans: number;\n    numBots: number;\n};\n\nexport interface PlayCardPayload {\n    id: number;\n    player: number;\n}\n\nexport interface CardPayload {\n    id: number;\n}\n\nexport interface PlayerPayload {\n    player: number;\n}\n\nexport type Action =\n    | { type: Actions.LoadGame, payload: GameState }\n    | { type: Actions.StartGame, payload: StartGamePayload }\n    | { type: Actions.PauseGame, payload: null }\n    | { type: Actions.ResumeGame, payload: null }\n    | { type: Actions.Resize, payload: DefaultPositions }\n    | { type: Actions.Deal, payload: null }\n    | { type: Actions.StartRound, payload: null }\n    | { type: Actions.PlayCard, payload: PlayCardPayload }\n    | { type: Actions.DiscardCard, payload: PlayCardPayload }\n    | { type: Actions.Think, payload: PlayerPayload }\n    | { type: Actions.Draw, payload: PlayerPayload }\n    | { type: Actions.WinRound, payload: PlayerPayload }\n    | { type: Actions.FinishAnimation, payload: CardPayload }\n    | { type: Actions.WinGame, payload: PlayerPayload }\n\nexport function reducer(draft: Draft<GameState>, action: Action): void {\n    switch(action.type) {\n        case Actions.LoadGame:\n            draft.cards = new Deck(...action.payload.cards);\n            draft.center = action.payload.center;\n            draft.previousCenter = action.payload.previousCenter;\n            draft.players = action.payload.players;\n            draft.turn = action.payload.turn;\n\n            break;\n\n        case Actions.StartGame:\n            let players = new Array<Player>();\n            for (let i = 0; i < action.payload.numHumans; i++) {\n                players.push({\n                    seat: i,\n                    name: `You`,\n                    strategy: new HumanStrategy(),\n                    toDiscard: 0,\n                });\n            }\n\n            for (let i = 0; i < action.payload.numBots; i++) {\n                players.push({\n                    seat: i + action.payload.numHumans,\n                    name: `Bot ${i + 1}`,\n                    strategy: new BotStrategy(),\n                    toDiscard: 0,\n                });\n            }\n\n            draft.cards = Deck.create();\n            draft.players = players;\n            draft.turn = {\n                player: Math.floor(Math.random() * players.length),\n                phase: Phase.Preround\n            };\n            break;\n\n        case Actions.PauseGame:\n            draft.paused = true;\n            break;\n\n        case Actions.ResumeGame:\n            draft.paused = false;\n            break;\n\n        case Actions.Resize:\n            draft.positions = action.payload;\n            draft.cards.map((c) => {\n                switch (c.location) {\n                    case Location.Center:\n                        c.pos = draft.positions.center;\n                        break;\n                    case Location.Deck:\n                        c.pos = draft.positions.deck;\n                        break;\n                    case Location.Discard:\n                        c.pos = draft.positions.discard;\n                        break;\n                    case Location.Hand:\n                        if (c.owner !== null) {\n                            c.pos = draft.positions.players[c.owner];\n                        }\n                        break;\n                }\n\n                return c;\n            });\n\n            break;\n\n        case Actions.Deal:\n            // 2-3 players = 9 cards, 4 players = 8 cards, 5 players = 7 cards\n            const baseCards = 9 - draft.players.length + 3;\n\n            moveToCenter(draft, draft.cards.find((c) => c.location === Location.Deck) as Card, false);\n\n            for (let seat = 0; seat < draft.players.length; seat++) {\n                for (let i = 0; i < baseCards + numWins(draft, seat); i++) {\n                    dealCard(draft, seat);\n                }\n            }\n\n            draft.turn.phase = Phase.Wait;\n            break;\n\n        case Actions.StartRound:\n            draft.cards.filter((c) => c.id === draft.center)[0].visible = true;\n            draft.turn.phase = Phase.Play;\n            break;\n\n        case Actions.PlayCard: {\n            const playedCard = getCard(draft, action.payload.id);\n            const center = getCard(draft, draft.center);\n            if (playedCard && center) {\n                const matches = numMatches(center, playedCard);\n                console.log(`${draft.players[action.payload.player].name} played ${cardToString(playedCard)}. It has ${matches} matches on ${cardToString(center)}`);\n\n                // On turn play\n                if (draft.turn.player === action.payload.player && matches > 0) {\n                    moveToCenter(draft, playedCard, true);\n                    \n                    if (matches - 1 > 0) {\n                        draft.turn.phase = Phase.Discard;\n                        draft.players[draft.turn.player].toDiscard = matches - 1;\n                    } else {\n                        draft.turn.player++;\n                        if (draft.turn.player >= draft.players.length) {\n                            draft.turn.player = 0;\n                        }\n                        draft.turn.phase = Phase.Play;\n                    }\n                } else if (draft.turn.player !== action.payload.player && matches === 3) {\n                    toast('Perfect Match!', { toastId: 'perfect-match' });\n\n                    // Perfect match, off turn\n                    moveToCenter(draft, playedCard, true);\n                    \n                    draft.turn.player = action.payload.player;\n                    draft.turn.phase = Phase.Play;\n                } else if (action.payload.player === 0) {\n                    // No match! (Do something?)\n                    toast.error('That card has no matches!', { toastId: 'rejected' });\n                }\n            }\n\n            break;\n        }\n\n        case Actions.DiscardCard: {\n            const playedCard = getCard(draft, action.payload.id);\n\n            if (playedCard) {\n                moveToDiscard(draft, playedCard);   \n                    \n                draft.players[draft.turn.player].toDiscard--;\n                console.log(`${draft.players[action.payload.player].name} discarded a card.`);\n\n                if (draft.players[draft.turn.player].toDiscard <= 0) {\n                    draft.turn.player++;\n                    if (draft.turn.player >= draft.players.length) {\n                        draft.turn.player = 0;\n                    }\n                    draft.turn.phase = Phase.Play;\n                }\n            }\n\n            break;\n        }\n\n        case Actions.Think:\n            if (draft.turn.player === action.payload.player) {\n                draft.turn.phase = Phase.Think;\n            }\n            break;\n\n        case Actions.Draw:\n            // Shuffle the discard pile back into the draw pile when it runs out\n            if (draft.cards.filter((c) => c.location === Location.Deck).length === 0) {\n                draft.cards.map((c) => {\n                    if (c.location === Location.Discard) {\n                        c.location = Location.Deck;\n                        c.pos = draft.positions.deck;\n                        c.animating = true;\n                    }\n\n                    return c;\n                });\n            }\n\n            if (draft.turn.player === action.payload.player) {\n                dealCard(draft, draft.turn.player);\n            }\n            break;\n\n        case Actions.WinRound:\n            toast(`${draft.players[action.payload.player].name} won the round!`, { toastId: 'win-round' });\n\n            moveToWin(draft, draft.cards.find((c) => c.location !== Location.Win) as Card, action.payload.player);\n            resetRound(draft, action.payload.player);\n\n            break;\n\n        case Actions.WinGame:\n            moveToWin(draft, draft.cards.find((c) => c.location !== Location.Win) as Card, action.payload.player);\n            draft.turn.phase = Phase.Postgame;\n\n            break;\n\n        case Actions.FinishAnimation:\n            const card = getCard(draft, action.payload.id);\n            if (card) {\n                card.animating = false;\n            }\n            break;\n\n        default:\n            throw new Error(`Unknown action ${JSON.stringify(action)}`)\n    }\n}\n\nfunction getCard(draft: Draft<GameState>, id: number): Card | undefined {\n    return draft.cards.find((c) => c.id === id);\n}\n\nfunction moveToCenter(draft: Draft<GameState>, card: Card, visible: boolean): void {\n    draft.previousCenter = draft.center;\n\n    card.location = Location.Center;\n    card.pos = draft.positions.center;\n    card.visible = visible;\n    card.owner = null;\n    card.animating = true;\n    \n    draft.center = card.id;\n}\n\nfunction moveToDiscard(draft: Draft<GameState>, card: Card): void {\n    card.location = Location.Discard;\n    card.pos = draft.positions.discard;\n    card.visible = false;\n    card.owner = null;\n    card.animating = true;\n}\n\nfunction resetRound(draft: Draft<GameState>, lastWinner: number) {\n    draft.cards.map((c) => {\n        if (c.location !== Location.Win) {\n            c.location = Location.Deck;\n            c.pos = draft.positions.deck;\n            c.visible = false;\n            c.owner = null;\n            c.animating = true;\n        }\n\n        return c;\n    });\n    draft.cards = draft.cards.shuffle();\n\n    draft.turn = {\n        player: lastWinner,\n        phase: Phase.Preround,\n    };\n\n    draft.players.forEach((player) => player.toDiscard = 0);\n}\n\nfunction numWins(draft: Draft<GameState>, seat: number): number {\n    return draft.cards.filter((c) => c.owner === seat && c.location === Location.Win).length;\n}\n\nfunction dealCard(draft: Draft<GameState>, seat: number): void {\n    let card = draft.cards.find((c) => c.location === Location.Deck);\n\n    if (card) {\n        card.pos = draft.positions.players[seat];\n        card.location = Location.Hand;\n        card.owner = seat;\n        card.visible = draft.players[seat].strategy.isHuman();\n        card.animating = true;\n    }\n}\n\nfunction moveToWin(draft: Draft<GameState>, card: Card, seat: number): void {\n    card.pos = draft.positions.win;\n    card.location = Location.Win;\n    card.owner = seat;\n    card.visible = false;\n}\n\nexport const getCenter = (state: GameState): Card => \n    state.cards.filter((c) => c.id === state.center)[0];\n\nexport const getHand = (state: GameState, player: number): Card[] => \n    state.cards.filter((c) => c.owner === player && c.location === Location.Hand);\n\nexport const getRoundWinner = (state: GameState): number | undefined => {\n    if (state.turn.phase === Phase.Preround) {\n        return undefined;\n    }\n\n    return state.players\n        .map((p) => ({ seat: p.seat, handSize: getHand(state, p.seat).length }))\n        .filter((p) => p.handSize === 0)\n        .map((p) => p.seat )\n        .shift();\n};\n\nexport const getGameWinner = (state: GameState): number | undefined => {\n    if (state.turn.phase === Phase.Preround) {\n        return undefined;\n    }\n\n    // Because of the state updates, we're actually checking for a win at the moment the\n    // player's hand goes to 0 and they have 2 wins already (which will be 3 in a second if they do).\n    return state.players\n        .map((p) => ({ seat: p.seat, handSize: getHand(state, p.seat).length, wins: numWins(state, p.seat) }))\n        .filter((p) => p.wins === 2 && p.handSize === 0)\n        .map((p) => p.seat)\n        .shift();\n};\n\nexport const animationRunning = (state: GameState): boolean => \n    state.cards.filter((c) => c.animating === true).length > 0;","import { useEffect, Dispatch } from 'react'\nimport { useImmerReducer } from 'use-immer';\nimport { reducer, initialState, getCenter, getRoundWinner, GameState, Action, Actions, animationRunning, getGameWinner } from '../types/GameState';\nimport { Phase } from '../types/Turn';\nimport { HumanStrategy, BotStrategy } from '../types/Player';\nimport usePositions, { DefaultPositions } from './usePositions';\n\nconst useGameState = (): { state: GameState, dispatch: Dispatch<Action>, positions: DefaultPositions } => {\n    const [state, dispatch] = useImmerReducer(reducer, initialState);\n    const positions = usePositions();\n\n    // Try to save/load the state from localstorage\n    useEffect(() => {\n        // Try to pull state from localstorage and only populate if we don't already have a state in memory\n        const gameData = window.localStorage.getItem('gameData')\n        if (gameData !== null && state === initialState) {\n            dispatch({ type: Actions.LoadGame, payload: JSON.parse(gameData, (key, value) => {\n                if (key === 'strategy') {\n                    return value === 'HumanStrategy' ? new HumanStrategy() : new BotStrategy();\n                }\n\n                return value;\n            })});\n        }\n\n        // Save state to localstorage if we have a state to save\n        if (state !== initialState) {\n            window.localStorage.setItem('gameData', JSON.stringify(state, (key, value) => {\n                if (key === 'strategy') {\n                    return value.timeout === undefined ? 'HumanStrategy' : 'BotStrategy';\n                }\n\n                return value;\n            }));\n        }\n    // eslint-disable-next-line\n    }, [state]);\n\n    // Update bots whenever state changes\n    useEffect(() => {\n        // No bot actions before/after the game/round starts or if there are active animations\n        if (state === initialState \n            || state.paused\n            || [Phase.Pregame, Phase.Preround, Phase.Postgame].includes(state.turn.phase) \n            || animationRunning(state)\n        ) {\n            return;\n        }\n\n        // Check for a round win\n        const roundWinner = getRoundWinner(state);\n        if (typeof roundWinner !== 'undefined') {\n            state.players.forEach((player) => player.strategy.cancelThoughts());\n\n            // Check for a game win\n            const gameWinner = getGameWinner(state);\n            if (typeof gameWinner !== 'undefined') {\n                dispatch({ type: Actions.WinGame, payload: { player: gameWinner }});\n            } else {\n                dispatch({ type: Actions.WinRound, payload: { player: roundWinner }});\n            }\n\n            return;\n        }\n\n        const center = getCenter(state);\n        let centerChanged = false;\n        if (center && center.visible && center.id !== state.previousCenter) {\n            centerChanged = true;\n        }\n\n        // Only allow a bot to play a card when the center card changes or when it's their turn\n        state.players.forEach((player) => {\n            if (state.turn.player === player.seat || centerChanged) {\n                player.strategy.onCardPlayed(player, state, dispatch)\n            }\n        });\n\n        // Only discard when you need to discard\n        state.players.forEach((player) => player.strategy.onDiscardNeeded(player, state, dispatch));\n    // eslint-disable-next-line\n    }, [state]);\n\n    useEffect(() => {\n        dispatch({ type: Actions.Resize, payload: positions });\n    // eslint-disable-next-line\n    }, [positions]);\n\n    return {\n        state,\n        dispatch,\n        positions,\n    };\n}\n\nexport default useGameState;\n","import React, { FC, CSSProperties, Dispatch, useEffect } from 'react';\nimport { Action, Actions } from '../types/GameState';\nimport { Card as CardModel } from '../types/Card';\nimport { Turn, Phase } from '../types/Turn';\n\nimport './Card.scss'\n\ntype CardProps = CardModel & {\n    dispatch: Dispatch<Action>;\n    turn: Turn;\n    index: number;\n}\n\nconst Card: FC<CardProps> = ({ index, id, color, wallpaper, decoration, visible, location, pos, owner, dispatch, turn, animating }) => {\n    useEffect(() => {\n        if (animating === true) {\n            setTimeout(() => dispatch({ type: Actions.FinishAnimation, payload: { id }}), 1000);\n        }\n    // eslint-disable-next-line\n    }, [id, animating, location])\n\n    const imageClass = visible\n        ? `${color}_${wallpaper}_${decoration}`\n        : `cardback`;\n\n    let style: CSSProperties = {\n        top: `${pos.y}px`,\n        left: `${pos.x}px`,\n        zIndex: index,\n    };\n\n    return (\n        <div\n            id={`card${id}`}\n            className={`card ${imageClass} ${visible ? 'front' : 'back'} ${location} ${owner ? `p${owner}` : ''}`}\n            style={style}\n            onClick={() => {\n                // Only human playable cards\n                if (owner === 0) {\n                    if (turn.player === 0 && turn.phase === Phase.Play) {\n                        // On turn\n                        dispatch({ type: Actions.PlayCard, payload: { id, player: 0 }})\n                    } else if (turn.player !== 0 && [Phase.Think, Phase.Play].includes(turn.phase)) {\n                        // Off turn perfect match\n                        dispatch({ type: Actions.PlayCard, payload: { id, player: 0 }})\n                    } else if (turn.player === 0 && turn.phase === Phase.Discard) {\n                        // Discard\n                        dispatch({ type: Actions.DiscardCard, payload: { id, player: 0 }})\n                    }\n                }\n            }}\n        />\n    )\n}\n\nexport default Card;\n","export default __webpack_public_path__ + \"static/media/title.66c1b04b.png\";","export default __webpack_public_path__ + \"static/media/rules-matching.f4f1f52e.png\";","export default __webpack_public_path__ + \"static/media/rules-discards.41b08232.png\";","export default __webpack_public_path__ + \"static/media/rules-perfect-match.23d58ce4.png\";","import React, { Dispatch, FC, useState, Fragment } from 'react';\nimport { Actions, Action } from '../types/GameState';\n\nimport './Rules.scss';\n\nimport title from '../img/title.png';\nimport matching from '../img/rules-matching.png';\nimport discards from '../img/rules-discards.png';\nimport perfect from '../img/rules-perfect-match.png';\n\ninterface RulesProps {\n    dispatch: Dispatch<Action>;\n    resume: boolean;\n}\n\nconst Rules: FC<RulesProps> = ({ dispatch, resume }) => {\n    const [page, setPage] = useState(0);\n\n    let instructions = <Fragment />\n    switch (page) {\n        case 0:\n        instructions = (\n            <Fragment>\n                <p>\n                    Compete with your fellow interior designers to suggest ideas for how this nook should look.\n                </p>\n                <img src={title} alt=\"Nook title\" />\n            </Fragment>\n        );\n        break;\n\n        case 1:\n        instructions = (\n            <Fragment>\n                <p>\n                    Play cards from your hand to create matches with the card in the center.\n                </p>\n                <img src={matching} alt=\"Rules on matching\" />\n            </Fragment>\n        );\n        break;\n\n        case 2:\n        instructions = (\n            <Fragment>\n                <p>\n                    The better the match, the more cards you can discard. Discard your hand first to win the round.\n                </p>\n                <img src={discards} alt=\"Rules on discarding\" />\n            </Fragment>\n        );\n        break;\n\n        case 3:\n        instructions = (\n            <Fragment>\n                <p>\n                    You can also play a perfect match at any time &mdash; even when it's not your turn. It will become your turn instantly!\n                </p>\n                <img src={perfect} alt=\"Rules on perfect matches\" />\n            </Fragment>\n        );\n        break;\n\n        case 4:\n        instructions = (\n            <Fragment>\n                <p>\n                    Be the first designer to empty your hand and you'll win the round! Win 3 rounds and you'll win the game. Good Luck!\n                </p>\n            </Fragment>\n        );\n        break;\n    }\n\n    return (\n        <div className=\"rules\">\n            <h1>nook</h1>\n\n            <div className=\"instructions-box\">\n                {instructions}\n                \n                <div className=\"instruction-page-buttons\">\n                    <button \n                        onClick={() => setPage(page - 1)}\n                        disabled={page === 0}\n                    >&larr;</button>\n\n                    <button \n                        onClick={() => setPage(page + 1)}\n                        disabled={page === 4}\n                    >&rarr;</button>\n                </div>\n            </div>\n\n            <button \n                className={page === 4 ? 'highlight' : ''}\n                onClick={() => {\n                    resume\n                        ? dispatch({ type: Actions.ResumeGame, payload: null })\n                        : dispatch({ type: Actions.StartGame, payload: { numHumans: 1, numBots: 3 }});\n                }}\n            >\n                {resume ? 'Resume' : 'Start'} Game\n            </button>\n        </div>\n    )\n}\n\nexport default Rules\n","import React, { FC, Dispatch, Fragment } from 'react';\nimport { GameState, Action, Actions } from '../types/GameState';\nimport { Phase } from '../types/Turn';\n\nimport './TurnTracker.scss';\n\ntype TurnTrackerProps = GameState & {\n    dispatch: Dispatch<Action>\n};\n\nconst TurnTracker: FC<TurnTrackerProps> = ({ players, turn, dispatch, positions }) => {\n    const style = {\n        top: `${positions.center.y + 300}px`, \n        left: `${positions.center.x - 150}px`,\n    }\n\n    return (\n        <div className={`turn-tracker ${turn.phase}`} style={style}>\n            {turn.phase === Phase.Preround ? (\n                <button \n                onClick={() => dispatch({ type: Actions.Deal, payload: null })}\n                >\n                    Deal\n                </button>\n            ) : <Fragment />}\n        \n            {turn.phase === Phase.Wait ? (\n                <button \n                onClick={() => dispatch({ type: Actions.StartRound, payload: null })}\n                >\n                    Ready?\n                </button>\n            ) : <Fragment />}\n\n            {[Phase.Play, Phase.Discard, Phase.Think].includes(turn.phase) ? (\n                <Fragment>\n                    <span>{turn.player === 0 ? 'Your' : `${players[turn.player].name}'s`} Turn</span>\n                    <span>\n                        (\n                        {turn.player === 0 \n                            ? `${turn.phase} ${players[turn.player].toDiscard > 0 ? `${players[turn.player].toDiscard} ` : 'a '}card${players[turn.player].toDiscard > 1 ? 's' : ''}`\n                            : `${turn.phase}ing...`}\n                        )\n                    </span>\n                </Fragment>\n            ) : <Fragment />}\n        </div>\n    )\n};\n\nexport default TurnTracker;\n","import React, { FC, Fragment } from 'react';\nimport { GameState } from '../types/GameState';\nimport { Location } from '../types/Location';\nimport { Phase } from '../types/Turn';\n\nimport './HandStats.scss';\n\n\ntype HandStatsProps = GameState & {\n    seat: number;\n};\n\nconst HandStats: FC<HandStatsProps> = ({ cards, players, turn, seat, positions }) => {\n    if ([Phase.Pregame].includes(turn.phase)) {\n        return <Fragment />;\n    }\n\n    const handSize = cards.filter((c) => c.owner === seat && c.location === Location.Hand).length;\n    const wins = cards.filter((c) => c.owner === seat && c.location === Location.Win).length;\n    const isAfterFirstRound = cards.filter((c) => c.location === Location.Deck).length !== cards.length;\n\n    let icon = <Fragment />;\n    if (turn.player === seat && turn.phase === Phase.Think) {\n        icon = <span className=\"icon\">🤔</span>;\n    } else if (turn.phase === Phase.Preround && isAfterFirstRound && seat !== 0) {\n        if (turn.player === seat) {\n            icon = <span className=\"icon\">😁</span>;\n        } else {\n            icon = <span className=\"icon\">😒</span>;\n        }\n    }\n\n    const style = {\n        top: `${positions.players[seat].y + 200}px`, \n        left: `${positions.players[seat].x - 100}px`,\n    }\n\n    return (\n        <div className={`hand-stats ${turn.player === seat ? 'highlight' : ''}`} style={style}>\n            <span className=\"bold\">{players[seat].name}</span>\n            <span>Hand: {handSize}</span>\n            <span>Wins: {wins}</span>\n            {icon}\n        </div>\n    )\n};\n\nexport default HandStats;\n","import React, { FC, Dispatch, Fragment } from 'react';\nimport { Action, Actions } from '../types/GameState';\n\nimport Rules from './Rules';\n\nimport './HelpButton.scss';\n\ntype HelpButtonProps = {\n    dispatch: Dispatch<Action>,\n    paused: boolean,\n};\n\nconst HelpButton: FC<HelpButtonProps> = ({ dispatch, paused }) => {\n\n    return ( \n        <Fragment>\n            {paused && <Rules dispatch={dispatch} resume={true} />}\n            <button \n                className=\"help-button\" \n                onClick={() => {\n                    paused\n                        ? dispatch({ type: Actions.ResumeGame, payload: null })\n                        : dispatch({ type: Actions.PauseGame, payload: null });\n                }}>&#8264;</button>\n        </Fragment>\n    )\n};\n\nexport default HelpButton;\n","import React, { FC, Dispatch, Fragment, CSSProperties } from 'react';\nimport { GameState, Action, Actions } from '../types/GameState';\nimport { Position } from '../types/Position';\nimport { Phase } from '../types/Turn';\n\ntype DrawCardButtonProps = GameState & {\n    dispatch: Dispatch<Action>;\n    pos: Position;\n}\n\nconst DrawCardButton: FC<DrawCardButtonProps> = ({ turn, dispatch, pos }) => {\n    const style: CSSProperties = {\n        position: 'relative',\n        top: `${pos.y + 210}px`,\n        left: `${pos.x}px`,\n    }\n\n    return turn.player === 0 && turn.phase === Phase.Play\n        ? <button style={style} onClick={() => dispatch({ type: Actions.Draw, payload: { player: 0 }})}>Draw</button>\n        : <Fragment />\n};\n\nexport default DrawCardButton;\n","import React, { Dispatch, FC } from 'react';\nimport { GameState, Actions, Action } from '../types/GameState';\n\nimport './OffBoarding.scss';\n\ninterface OffBoardingProps {\n    state: GameState;\n    dispatch: Dispatch<Action>;\n}\n\nconst OffBoarding: FC<OffBoardingProps> = ({ state, dispatch }) => {\n    return (\n        <div className=\"offboarding\">\n            <h1>{state.players[state.turn.player].name} win{state.turn.player === 0 ? '' : 's'}!</h1>\n            <p>Thanks for playing nook!</p>\n\n            <button \n                onClick={() => dispatch({ type: Actions.StartGame, payload: { numHumans: 1, numBots: 3 }})}\n            >\n                Play Again?\n            </button>\n        </div>\n    )\n}\n\nexport default OffBoarding\n","import React, { useMemo, Fragment } from 'react';\nimport { Phase } from './types/Turn';\nimport { getLocationSortOrder } from './types/Location';\nimport useGameState from './util/useGameState';\n\nimport Card from './components/Card';\nimport Rules from './components/Rules';\nimport TurnTracker from './components/TurnTracker';\nimport HandStats from './components/HandStats';\nimport HelpButton from './components/HelpButton';\nimport DrawCardButton from './components/DrawCardButton';\nimport OffBoarding from './components/OffBoarding';\n\nimport './App.scss'\n\n\nfunction App() {\n  const { state, dispatch, positions } = useGameState();\n\n  const cards = useMemo(() => \n    state.cards.map((c) => ({ c, sort: getLocationSortOrder(c.location) + (c.owner ? c.owner : 0) })),\n    [state.cards]\n  );\n\n  if (state.turn.phase === Phase.Pregame) {\n    return <Rules dispatch={dispatch} resume={false} />\n  }\n\n  if (state.turn.phase === Phase.Postgame) {\n    return <OffBoarding state={state} dispatch={dispatch} />\n  }\n\n  return (\n    <div className=\"App\">\n      {!state.paused && (\n        <Fragment>\n          <TurnTracker {...state} dispatch={dispatch} />\n\n          {state.players.map((p, i) => (\n            <HandStats key={`hand-${i}`} {...state} seat={p.seat} />\n          ))}\n\n          {cards.map(({ c, sort }) => (\n            <Card\n              key={c.id}\n              {...c}\n              index={state.center === c.id ? 200 : (state.previousCenter === c.id ? 100 : sort)}\n              dispatch={dispatch}\n              turn={state.turn}\n            />\n          ))}\n\n          <DrawCardButton {...state} dispatch={dispatch} pos={positions.deck} />\n        </Fragment>\n      )}\n\n      <HelpButton dispatch={dispatch} paused={state.paused} />\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ToastContainer } from 'react-toastify';\n\nimport App from './App';\n\nimport './index.css';\nimport 'react-toastify/dist/ReactToastify.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ToastContainer\n      position=\"top-center\"\n      autoClose={3000}\n      hideProgressBar\n      newestOnTop={false}\n      closeOnClick={false}\n      closeButton={false}\n      rtl={false}\n      pauseOnFocusLoss={false}\n      draggable={false}\n      pauseOnHover={false}\n      className=\"toaster\"\n      toastClassName=\"info\"\n    />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}